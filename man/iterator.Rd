% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter.R
\name{iterator}
\alias{iterator}
\alias{new_iterator}
\alias{is_iterator}
\alias{deref}
\alias{advance}
\alias{is_done}
\alias{as_iterator}
\title{Iterator functions}
\usage{
new_iterator(fn)

is_iterator(x)

deref(iter)

advance(iter)

is_done(iter)

as_iterator(x)
}
\arguments{
\item{fn}{An iterable function. It should be callable without
arguments and return \code{NULL} when the iterator is exhausted.}

\item{x}{For \code{is_iterator()}, an object to test. For
\code{as_iterator()}, a vector, iterator, or iterable function. S3
objects with \code{length()} and position-based \code{[[} methods are also
supported.}

\item{iter}{An iterator function.}
}
\description{
R programming is usually about full lists and vectors. Vectorised
operations such as \code{+} or function mappers like \code{lapply()} operate
on whole collections of elements. However these idioms do not work
so well when the data does not fit in memory or when the data
arrives continuously and we need to work on it as it is coming
in. In these cases vector idioms must be replaced with steams of
chunked data idioms. Iterators are a convenient way of structuring
the generation of chunks of data. Iterators can easily be
\link[=iter_adapt]{transformed}, \link[=steps]{mapped over}, or
\link[=drain]{drained} to a final output vector.

Formally, an iterator is a function that returns a new value each
time it is called and that supports:
\itemize{
\item \code{deref()} to dereference the current value of the iterator.
\item \code{is_done()} to check if the iterator has exhausted its
elements. Calling an exhausted iterator causes an error of class
\code{exhausted_iter}.
\item \code{advance()} to advance to the next value. This is similar to
calling the iterator for a new element but returns \code{TRUE} if the
iterator indeed had another element or \code{FALSE} if the iterator
was exhausted. The element can then be retrieved with \code{deref()}.
}

The recommended way of creating an iterator is with \code{\link[=generator]{generator()}}.
}
\section{Creating iterators}{


There are three ways of creating an iterator:
\itemize{
\item \code{\link[=generator]{generator()}} is the recommended way of creating an iterator. It
creates a generator function that can pause itself and yield a
value. When it is called again it resumes from where it left
off. Generators are a convenient way of creating iterators
because they keep their state.
\item \code{new_iterator()} takes an iterable function (see section below)
and wraps it in a proper iterator that can be dereferenced and
advanced.
\item \code{as_iterator()} also supports vectors. It creates an iterator
that iterates over the elements. If passed a regular function, it
is equivalent to \code{new_iterator()}. If passed an iterator, it is a
no-op. \code{as_iterator()} is convenient for creating functions that
support both iterators and vectors.

Vector-like objects are also supported if the class implements
\code{length()} and \code{[[} methods. The extraction method must support
positions.
}
}

\section{Termination of an iterator}{


There is no general way to know in advance whether an iterator has
remaining elements. E.g. when iterating over a stream of data the
stream might close abruptly. The main purpose of \code{advance()} and
\code{deref()} is to make it easy to work with iterators.
\itemize{
\item You first try to \code{advance()} your iterator. If advance was
succesful, the iterator now sits at the next value. Otherwise the
iterator is done and you can finish the current operation.
\item If there was indeed a next value, you can obtain it by
dereferencing the iterator with \code{deref()}.
}

The idiom of advancing and dereferencing is useful for looping
manually over an iterator:\preformatted{while (advance(iter)) do(deref(iter))
}

Note that functions like \code{\link[=iterate]{iterate()}} or \code{\link[=drain]{drain()}} deal with the
looping automatically so that you don't have to worry about
termination and derefencing.
}

\section{Iterable functions}{


Technically, iterators are thin wrappers around iterable functions
which do the actual work of generating data. While in most cases
\code{\link[=generator]{generator()}} is sufficient to create iterators, it is also
possible to create iterators with normal (but iterable) functions
that you pass to \code{new_iterator()}. In order to be iterable, a
function must meet these requirements:
\itemize{
\item It should be callable without arguments. This is how the iterator
obtains the next value.
\item It should signal termination by returning \code{NULL}. If the next
element is a literal \code{NULL}, you can return a \link[=null_box]{boxed NULL}. It will be automatically unboxed and won't cause
the iterator to terminate.
}
}

\examples{
# An iterator is a stateful function since it must return different
# results each time it is called. A convenient way of setting up
# the state is with a factory function, i.e. a function that
# returns another function:
new_counter <- function(n) {
  force(n)

  # Wrapping the lambda function in an iterator enables many features
  new_iterator(function() {
    if (n == 0) {
      # Return NULL to finish iteration
      return(NULL)
    }

    # Update the counter each time:
    n <<- n - 1

    n
  })
}

# We can instantiate a new iterator by calling the factory:
iter <- new_counter(3)
iter()

# This function supports all iterator features. It can be
# dereferenced, advanced, and tested for termination:
advance(iter)
deref(iter)
is_done(iter)

# A tricky aspect of iterators is that they don't know whether
# there is a next element. Always use `advance()` when looping over
# an iterator. It tries to advance to the next element and returns
# TRUE if it was succeful, FALSE otherwise. You then use `deref()`
# to get the value of this new element:
iter <- new_counter(3)
while (advance(iter)) {
  cat(deref(iter), "to go!\\n")
}

# It is often easier to loop over an iterator with `iterate()`. It
# instruments `for` and makes it handle iterators:
iter <- new_counter(3)
iterate(for(n in iter) cat(n, "to go!\\n"))


# It is much easier to create iterators with generators:
new_counter <- function(n) {
  force(n)
  generator({
    while (n > 0) {
      n <- n - 1
      yield(n)
    }
  })
}

# This generator behaves exactly as our other iterator function:
iter <- new_counter(3)
iterate(for(n in iter) cat(n, "to go!\\n"))
}
\seealso{
\code{\link[=generator]{generator()}} is the recommended way of creating iterators.
}
